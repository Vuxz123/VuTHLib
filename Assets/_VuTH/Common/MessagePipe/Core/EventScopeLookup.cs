using System;
using System.Collections.Generic;
using _VuTH.Common.MessagePipe.Attributes;
using UnityEngine;

namespace _VuTH.Common.MessagePipe.Core
{
    /// <summary>
    /// Baked lookup asset containing all MessagePipe event types and their scopes.
    /// Generated by the editor baker. Do not edit manually.
    /// </summary>
    public class EventScopeLookup : ScriptableObject
    {
        [Header("Metadata")]
        [Tooltip("Version number, incremented on each bake")]
        [SerializeField] private int version;

        [Tooltip("MD5 checksum of source data to detect stale bakes")]
        [SerializeField] private string checksum;

        [Tooltip("Timestamp of last bake (UTC)")]
        [SerializeField] private string bakedAt;

        [Header("Event Entries")]
        [SerializeField] private List<EventScopeEntry> entries = new();

        public int Version => version;
        public string Checksum => checksum;
        public string BakedAt => bakedAt;
        public IReadOnlyList<EventScopeEntry> Entries => entries;

        // Runtime cache for fast lookup
        private Dictionary<string, EventScope> _cache;

        /// <summary>
        /// Get scope for a type by full name. Returns Global if not found.
        /// </summary>
        public EventScope GetScope(string typeFullName)
        {
            EnsureCache();
            return _cache.GetValueOrDefault(typeFullName, EventScope.Global);
        }

        /// <summary>
        /// Get scope for a type. Returns Global if not found.
        /// </summary>
        public EventScope GetScope(Type type)
        {
            return GetScope(type.FullName);
        }

        /// <summary>
        /// Get all entries with a specific scope.
        /// </summary>
        public IEnumerable<EventScopeEntry> GetEntriesByScope(EventScope scope)
        {
            foreach (var entry in entries)
            {
                if (entry.scope == scope)
                    yield return entry;
            }
        }

        /// <summary>
        /// Get all entries with a specific scope and scene name.
        /// For Scene scope, matches entries where sceneName matches (or both empty).
        /// For Global scope, returns empty (Global events have no scene restriction).
        /// </summary>
        public IEnumerable<EventScopeEntry> GetEntriesByScopeAndScene(EventScope scope, string sceneName)
        {
            foreach (var entry in entries)
            {
                if (entry.scope != scope)
                    continue;

                if (scope == EventScope.Global)
                    continue; // Global events are not scene-specific

                // For Scene scope, match by sceneName (allow empty to mean "any" if needed, but currently we require explicit match)
                if (string.Equals(entry.sceneName, sceneName, StringComparison.Ordinal))
                    yield return entry;
            }
        }

        /// <summary>
        /// Get all entries with Scene scope that do NOT have a matching sceneName (used for warning).
        /// </summary>
        public IEnumerable<EventScopeEntry> GetSceneEntriesWithMismatchedScene(string activeSceneName)
        {
            foreach (var entry in entries)
            {
                if (entry.scope != EventScope.Scene)
                    continue;

                if (!string.Equals(entry.sceneName, activeSceneName, StringComparison.Ordinal))
                    yield return entry;
            }
        }

        /// <summary>
        /// Try to resolve Type from entry. Returns null if type not found.
        /// Uses AssemblyQualifiedName for O(1) lookup via Type.GetType().
        /// </summary>
        public static Type ResolveType(EventScopeEntry entry)
        {
            if (string.IsNullOrEmpty(entry.typeFullName))
                return null;

            return Type.GetType(entry.typeFullName);
        }

        private void EnsureCache()
        {
            if (_cache != null) return;

            _cache = new Dictionary<string, EventScope>(entries.Count);
            foreach (var entry in entries)
            {
                if (!string.IsNullOrEmpty(entry.typeFullName))
                    _cache[entry.typeFullName] = entry.scope;
            }
        }

        private void OnEnable()
        {
            // Clear cache on enable to ensure fresh data after domain reload
            _cache = null;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Editor-only: Update entries and metadata. Used by baker.
        /// </summary>
        public void SetData(List<EventScopeEntry> newEntries, string newChecksum)
        {
            entries = newEntries ?? new List<EventScopeEntry>();
            checksum = newChecksum;
            version++;
            bakedAt = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC");
            _cache = null;
        }
#endif
    }
}
