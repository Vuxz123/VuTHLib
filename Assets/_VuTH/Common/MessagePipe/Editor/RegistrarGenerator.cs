using System.Collections.Generic;
using System.IO;
using _VuTH.Common.MessagePipe.Attributes;
using _VuTH.Common.MessagePipe.Core;
using Cysharp.Text;
using UnityEditor;
using UnityEngine;
using ZLinq;

namespace _VuTH.Common.MessagePipe.Editor
{
    /// <summary>
    /// Generates MessagePipeRegistrar.cs with optimized event registration.
    /// </summary>
    internal static class RegistrarGenerator
    {
        internal const string RegistrarFileName = "MessagePipeRegistrar.cs";
        internal const string RegistrarFolder = "Assets/Game/Scripts/Generated";
        private const string RegistrarNamespace = "Core.Generated";
        private const string RegistrarClassName = "MessagePipeRegistrar";

        /// <summary>
        /// Generate MessagePipeRegistrar.cs with optimized event registration.
        /// This eliminates per-event runtime reflection by generating direct type references.
        /// </summary>
        public static void GenerateRegistrar(List<EventScopeEntry> entries, bool preserveRegistrar = true)
        {
            // Ensure generated folder exists
            if (!AssetDatabase.IsValidFolder(RegistrarFolder))
            {
                PathUtilities.EnsureFolderExists(RegistrarFolder);
            }

            // Separate global and scene events
            var globalEvents = entries.AsValueEnumerable().Where(e => e.scope == EventScope.Global).ToList();
            var sceneEvents = entries.AsValueEnumerable().Where(e => e.scope == EventScope.Scene).ToList();

            // Group scene events by scene name
            var sceneEventGroups = sceneEvents
                .AsValueEnumerable()
                .GroupBy(e => e.sceneName)
                .OrderBy(g => g.Key)
                .ToList();

            using var sb = ZString.CreateStringBuilder();

            // Auto-generated header
            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by MessagePipeEventBaker.");
            sb.AppendLine("//     Runtime Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("// ------------------------------------------------------------------------------");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using MessagePipe;");
            sb.AppendLine("using UnityEngine.Scripting;");
            sb.AppendLine("#if VCONTAINER");
            sb.AppendLine("using VContainer;");
            sb.AppendLine("#endif");
            sb.AppendLine("using VuTH.Common.MessagePipe;");
            sb.AppendLine();
            sb.AppendLine($"namespace {RegistrarNamespace}");
            sb.AppendLine("{");
            if (preserveRegistrar)
            {
                sb.AppendLine("    [VContainer.Preserve]");
            }
            sb.AppendLine($"    public static class {RegistrarClassName}");
            sb.AppendLine("    {");
            sb.AppendLine();

            // RegisterGlobal method for VContainer
            sb.AppendLine("        #if VCONTAINER");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Register all global-scoped MessagePipe events to the VContainer builder.");
            sb.AppendLine("        /// Also registers MessagePipe core services.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static void RegisterGlobal(IContainerBuilder builder)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (builder == null) throw new ArgumentNullException(nameof(builder));");
            sb.AppendLine();
            sb.AppendLine("            // Get configured MessagePipeOptions");
            sb.AppendLine("            var options = MessagePipeHelper.GetConfiguredOptions();");
            sb.AppendLine();
            sb.AppendLine("            // Register MessagePipe core services");
            sb.AppendLine("            builder.RegisterMessagePipe();");
            sb.AppendLine();
            sb.AppendLine("            // Register global-scoped event brokers");
            foreach (var entry in globalEvents)
            {
                var typeName = GetTypeName(entry.typeFullName);
                sb.AppendLine($"            builder.RegisterMessageBroker<{typeName}>(options);");
                if (entry.registerAsyncBroker)
                {
                    sb.AppendLine($"            builder.RegisterAsyncMessageBroker<{typeName}>(options);");
                }
            }
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Register scene-scoped MessagePipe events to the VContainer builder.");
            sb.AppendLine("        /// Filters events by the active scene name.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static void RegisterScene(IContainerBuilder builder, string activeSceneName)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (builder == null) throw new ArgumentNullException(nameof(builder));");
            sb.AppendLine("            if (activeSceneName == null) throw new ArgumentNullException(nameof(activeSceneName));");
            sb.AppendLine();
            sb.AppendLine("            // Get configured MessagePipeOptions");
            sb.AppendLine("            var options = MessagePipeHelper.GetConfiguredOptions();");
            sb.AppendLine();
            sb.AppendLine("            // Register scene-scoped event brokers with scene name filtering");

            // Generate switch/if for scene events
            if (sceneEventGroups.Count > 0)
            {
                foreach (var group in sceneEventGroups)
                {
                    var sceneName = group.Key;
                    sb.AppendLine();
                    sb.AppendLine($"            if (activeSceneName == \"{sceneName}\")");
                    sb.AppendLine("            {");
                    foreach (var entry in group)
                    {
                        var typeName = GetTypeName(entry.typeFullName);
                        sb.AppendLine($"                builder.RegisterMessageBroker<{typeName}>(options);");
                        if (entry.registerAsyncBroker)
                        {
                            sb.AppendLine($"                builder.RegisterAsyncMessageBroker<{typeName}>(options);");
                        }
                    }
                    sb.AppendLine("                return;");
                    sb.AppendLine("            }");
                }
            }
            else
            {
                sb.AppendLine("            // No scene-scoped events defined");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Non-VContainer path
            sb.AppendLine("        #else");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Register all MessagePipe events to BuiltinContainerBuilder (non-VContainer mode).");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static void RegisterGlobal(BuiltinContainerBuilder builder)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (builder == null) throw new ArgumentNullException(nameof(builder));");
            sb.AppendLine();
            sb.AppendLine("            // Get configured MessagePipeOptions");
            sb.AppendLine("            var options = MessagePipeHelper.GetConfiguredOptions();");
            sb.AppendLine();
            sb.AppendLine("            builder.AddMessagePipe();");
            sb.AppendLine();
            sb.AppendLine("            // Register all events as global (scene scope not supported without VContainer)");
            foreach (var entry in entries)
            {
                var typeName = GetTypeName(entry.typeFullName);
                sb.AppendLine($"            builder.AddMessageBroker<{typeName}>();");
            }
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        #endif");
            sb.AppendLine();
            sb.AppendLine("        // Helper method to get all event types (useful for debugging/inspection)");
            sb.AppendLine("        public static IEnumerable<Type> GetAllEventTypes()");
            sb.AppendLine("        {");
            if (entries.Count > 0)
            {
                foreach (var entry in entries)
                {
                    var typeName = GetTypeName(entry.typeFullName);
                    sb.AppendLine($"            yield return typeof({typeName});");
                }
            }
            else
            {
                sb.AppendLine("            yield break;");
            }
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            var filePath = Path.Combine(RegistrarFolder, RegistrarFileName);
            File.WriteAllText(filePath, sb.ToString());
            AssetDatabase.Refresh();

            Debug.Log($"[MessagePipe Baker] Generated {RegistrarFileName} at {filePath} " +
                     $"({globalEvents.Count} global, {sceneEvents.Count} scene events)");
        }

        /// <summary>
        /// Extract the type name from assembly-qualified name.
        /// Handles both simple type names and generic types.
        /// </summary>
        public static string GetTypeName(string assemblyQualifiedName)
        {
            if (string.IsNullOrEmpty(assemblyQualifiedName))
                return "UNKNOWN";

            // Handle generic types like "SomeEvent`1[[System.Int32, mscorlib]], AssemblyName"
            var genericBacktick = assemblyQualifiedName.IndexOf('`');
            if (genericBacktick > 0)
            {
                // Extract the type name up to the backtick, including generic arity
                using var sb = ZString.CreateStringBuilder();
                var i = 0;
                while (i < assemblyQualifiedName.Length && assemblyQualifiedName[i] != ',')
                {
                    sb.Append(assemblyQualifiedName[i]);
                    i++;
                }
                return sb.ToString();
            }

            // Handle simple types: "Namespace.TypeName, AssemblyName"
            var commaIndex = assemblyQualifiedName.IndexOf(',');
            return commaIndex > 0 ? assemblyQualifiedName[..commaIndex] : assemblyQualifiedName;
        }
    }
}
